# Phase 3.3: 監視・セキュリティ設定

## 概要

最小限の監視・ロギング機能とセキュリティ対策を実装します。SSH公開鍵認証、fail2ban、SELinux、自動セキュリティアップデート、logwatch、アラート通知を設定します。

## 前提条件

- Phase 3.1（Docker環境構築）完了
- Phase 3.2（ストレージ・バックアップ設定）完了
- SSH公開鍵ペアを準備（未作成の場合は手順内で作成）
- Discord Webhookの作成（オプション、手順内で説明）

## 推定所要時間

60分

## 構築手順

### ステップ1: SSH公開鍵ペアの作成（ローカルマシン側）

ローカルマシン（MacBook等）で SSH公開鍵ペアを作成します。**既にSSH鍵がある場合はこのステップをスキップ**してください。

#### 実行コマンド（ローカルマシン）

```bash
# SSH鍵の存在確認
ls -la ~/.ssh/id_ed25519*

# 鍵が存在しない場合、新規作成
ssh-keygen -t ed25519 -C "your_email@example.com"

# 鍵の確認
ls -la ~/.ssh/
```

#### 期待される出力

```
-rw-------  1 user  staff  464 ... id_ed25519
-rw-r--r--  1 user  staff  103 ... id_ed25519.pub
```

#### 検証項目

- **アクション**: `cat ~/.ssh/id_ed25519.pub` を実行し、公開鍵が表示されるか確認する
- **期待結果**: `ssh-ed25519 AAAA...` で始まる公開鍵が表示される
- **失敗時**: ssh-keygen コマンドを再実行、パスフレーズは任意（推奨: 設定する）

---

### ステップ2: SSH公開鍵のサーバーへの登録

ローカルマシンの公開鍵をDell WorkStation（Rocky Linux）に登録します。

#### 実行コマンド（ローカルマシン）

```bash
# ssh-copy-idを使用した公開鍵登録（推奨）
ssh-copy-id -i ~/.ssh/id_ed25519.pub username@dell-workstation

# 接続テスト
ssh -i ~/.ssh/id_ed25519 username@dell-workstation
```

**ssh-copy-idが使えない場合の手動登録**:

```bash
# 公開鍵をコピー
cat ~/.ssh/id_ed25519.pub

# サーバー側（Dell WorkStation）で実行
mkdir -p ~/.ssh
chmod 700 ~/.ssh
echo "ssh-ed25519 AAAA... your_email@example.com" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

#### 期待される出力

```
Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'username@dell-workstation'"
and check to make sure that only the key(s) you wanted were added.
```

#### 検証項目

- **アクション**: `ssh username@dell-workstation` を実行し、パスワードなしでログインできるか確認する
- **期待結果**: 公開鍵認証でログインできる（パスワード入力不要）
- **失敗時**: ~/.ssh/authorized_keys の権限確認 `chmod 600 ~/.ssh/authorized_keys`

---

### ステップ3: SSHサーバー設定の変更（パスワード認証無効化）

SSH公開鍵認証を強制し、パスワード認証を無効化します。

**⚠️ 重要警告**: この手順を誤るとSSH接続が完全に不可能になります。以下の安全確認手順を厳守してください。

#### 安全な変更手順

**前提条件確認**:
1. **必須**: 別のターミナルでSSH接続を維持したまま作業する
2. **必須**: 公開鍵認証でログインできることを**3回以上**確認する
3. **推奨**: コンソールアクセス（直接ログイン）が可能な環境を準備

#### 実行コマンド（サーバー側）

**Phase 1: バックアップと公開鍵認証確認**

```bash
# SSH設定のバックアップ
sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup_$(date +%Y%m%d_%H%M%S)

# 公開鍵認証が動作するか確認（新しいターミナルで実行）
# 以下のコマンドをローカルマシンで実行し、パスワードなしでログインできることを確認
# ssh username@dell-workstation "echo 'SSH Public Key Auth: OK'"
```

**Phase 2: 設定変更（既存セッションを維持したまま）**

```bash
# SSH設定の変更
sudo tee /etc/ssh/sshd_config.d/99-security.conf > /dev/null <<'EOF'
# SSH Security Hardening
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
ChallengeResponseAuthentication no
UsePAM yes
EOF

# 設定の構文チェック
sudo sshd -t
```

**Phase 3: 設定反映と安全確認**

```bash
# SSHサービスの再起動（既存セッションは維持される）
sudo systemctl restart sshd

# サービス状態確認
sudo systemctl status sshd
```

**Phase 4: 新規接続テスト（既存セッションを維持したまま）**

```bash
# 【重要】新しいターミナルを開き、以下を実行
# ローカルマシンから:
# ssh username@dell-workstation

# 成功した場合のみ、元のセッションを閉じる
# 失敗した場合は、元のセッションでロールバック（下記参照）
```

#### ロールバック手順（接続失敗時）

元のセッションで以下を実行:

```bash
# バックアップから復元
sudo cp /etc/ssh/sshd_config.backup_* /etc/ssh/sshd_config
sudo rm /etc/ssh/sshd_config.d/99-security.conf
sudo systemctl restart sshd

# 確認
ssh username@dell-workstation  # ローカルマシンから再テスト
```

コンソールアクセス経由での復旧:

```bash
# 直接ログイン後
sudo cp /etc/ssh/sshd_config.backup_* /etc/ssh/sshd_config
sudo systemctl restart sshd
```

#### 期待される出力

```
（設定チェックでエラーなし）
● sshd.service - OpenSSH server daemon
   Active: active (running)

# 新規接続テスト成功
SSH Public Key Auth: OK
```

#### 検証項目

- **アクション**: 以下の3段階確認を実施する
  1. 既存セッションが維持されている
  2. **新しいターミナル**で公開鍵認証ログイン成功
  3. **新しいターミナル**でパスワード認証が拒否される（`ssh -o PreferredAuthentications=password username@dell-workstation` → Permission denied）
- **期待結果**: 公開鍵認証のみ成功、パスワード認証は拒否される
- **失敗時**: 上記ロールバック手順を実行

---

### ステップ4: fail2banのインストールと設定

ブルートフォース攻撃を防ぐため、fail2banをインストール・設定します。

#### 実行コマンド

```bash
# fail2banのインストール
sudo dnf install -y epel-release
sudo dnf install -y fail2ban

# 設定ファイルのコピー
sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local

# カスタム設定の追加（Discord通知統合版）
sudo tee /etc/fail2ban/jail.d/custom.conf > /dev/null <<'EOF'
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5
destemail = admin@example.com
action = %(action_mwl)s

[sshd]
enabled = true
port = 22
logpath = /var/log/secure
maxretry = 5
action = %(action_mwl)s
         discord-notify
EOF

# fail2banサービスの起動と自動起動設定
sudo systemctl start fail2ban
sudo systemctl enable fail2ban

# サービス状態確認
sudo systemctl status fail2ban

# fail2ban動作確認
sudo fail2ban-client status
sudo fail2ban-client status sshd
```

#### 期待される出力

```
● fail2ban.service - Fail2Ban Service
   Active: active (running)

Status for the jail: sshd
|- Filter
|  |- Currently failed: 0
|- Actions
   |- Currently banned: 0
```

#### 検証項目

- **アクション**: `sudo fail2ban-client status sshd` を実行する
- **期待結果**: sshdジェイルが有効で、Currently failed と Currently banned が表示される
- **失敗時**: `sudo journalctl -u fail2ban -xe` でエラー確認、設定ファイル構文チェック

---

### ステップ5: SELinuxの設定確認

SELinuxがEnforcingモードで動作していることを確認します。

#### 実行コマンド

```bash
# SELinuxモード確認
getenforce

# SELinux状態詳細確認
sestatus

# SELinux設定ファイル確認
sudo cat /etc/selinux/config | grep SELINUX=
```

#### 期待される出力

```
Enforcing

SELinux status:                 enabled
Current mode:                   enforcing
Mode from config file:          enforcing
```

#### 検証項目

- **アクション**: `getenforce` を実行する
- **期待結果**: `Enforcing` が表示される
- **失敗時**: `/etc/selinux/config` で `SELINUX=enforcing` に設定し、OS再起動

**注意**: SELinuxがPermissiveまたはDisabledの場合、Enforcingに変更後はOS再起動が必要です。

---

### ステップ6: 自動セキュリティアップデート（dnf-automatic）の設定

週1回の自動セキュリティアップデートを設定します。

#### 実行コマンド

```bash
# dnf-automaticのインストール
sudo dnf install -y dnf-automatic

# 設定ファイルの編集
sudo tee /etc/dnf/automatic.conf > /dev/null <<'EOF'
[commands]
upgrade_type = security
download_updates = yes
apply_updates = yes
random_sleep = 360

[emitters]
emit_via = stdio
system_name = dell-workstation

[email]
email_from = root@localhost
email_to = admin@example.com
email_host = localhost
EOF

# タイマーの有効化（週1回実行）
sudo systemctl enable --now dnf-automatic.timer

# タイマー状態確認
sudo systemctl status dnf-automatic.timer

# 次回実行時刻確認
sudo systemctl list-timers dnf-automatic.timer
```

#### 期待される出力

```
● dnf-automatic.timer - dnf-automatic timer
   Loaded: loaded (/usr/lib/systemd/system/dnf-automatic.timer; enabled)
   Active: active (waiting)
```

#### 検証項目

- **アクション**: `sudo systemctl is-enabled dnf-automatic.timer` を実行する
- **期待結果**: `enabled` が表示される
- **失敗時**: `sudo systemctl enable dnf-automatic.timer` を再実行

---

### ステップ7: logwatchのインストールと設定

日次ログレポート生成のため、logwatchをインストール・設定します。

#### 実行コマンド

```bash
# logwatchのインストール
sudo dnf install -y logwatch

# 設定ファイルの作成
sudo mkdir -p /etc/logwatch/conf
sudo tee /etc/logwatch/conf/logwatch.conf > /dev/null <<'EOF'
Output = stdout
Format = text
Encode = none
MailTo = admin@example.com
MailFrom = logwatch@dell-workstation
Range = Yesterday
Detail = Med
Service = All
Service = -zz-disk_space
Service = -zz-network
Service = -zz-sys
LogDir = /var/log
TmpDir = /var/cache/logwatch
EOF

# Dockerログ用カスタムサービス設定
sudo mkdir -p /etc/logwatch/conf/logfiles
sudo tee /etc/logwatch/conf/logfiles/docker.conf > /dev/null <<'EOF'
LogFile = /var/log/messages
*RemoveHeaders
*ApplyStdDate
EOF

sudo mkdir -p /etc/logwatch/conf/services
sudo tee /etc/logwatch/conf/services/docker.conf > /dev/null <<'EOF'
Title = "Docker Containers"
LogFile = docker
EOF

# Dockerログ解析スクリプトの配置
sudo mkdir -p /etc/logwatch/scripts/services
sudo tee /etc/logwatch/scripts/services/docker > /dev/null <<'EOF'
#!/usr/bin/env python3
import re
import sys
from collections import Counter

START_PATTERNS = (
    re.compile(r"container (started|start)", re.IGNORECASE),
    re.compile(r"started container", re.IGNORECASE),
)
STOP_PATTERNS = (
    re.compile(r"container (stopped|stop)", re.IGNORECASE),
    re.compile(r"stopped container", re.IGNORECASE),
    re.compile(r"killing container", re.IGNORECASE),
)
PULL_PATTERNS = (
    re.compile(r"pulling image", re.IGNORECASE),
    re.compile(r"downloaded newer image", re.IGNORECASE),
    re.compile(r"image (pull|download) complete", re.IGNORECASE),
)

counters = Counter()
for raw in sys.stdin:
    line = raw.strip()
    if not line:
        continue
    lowered = line.lower()
    if "docker" not in lowered and "container" not in lowered:
        continue
    if any(pattern.search(line) for pattern in START_PATTERNS):
        counters["Container Started"] += 1
    elif any(pattern.search(line) for pattern in STOP_PATTERNS):
        counters["Container Stopped"] += 1
    elif any(pattern.search(line) for pattern in PULL_PATTERNS):
        counters["Image Pulled"] += 1

print(" --------------------- Docker Begin ------------------------")
if counters:
    for key in ("Container Started", "Container Stopped", "Image Pulled"):
        print(f" {key}: {counters.get(key, 0)} events")
else:
    print(" No Docker events recorded for the selected range.")
print(" ---------------------- Docker End -------------------------")
EOF
sudo chmod +x /etc/logwatch/scripts/services/docker

# 手動実行テスト
sudo /usr/sbin/logwatch --detail Med --range today --output stdout | head -50
```

#### 期待される出力

```
################### Logwatch 7.x (MM/DD/YY) ####################
Processing Initiated: ...
Date Range Processed: yesterday
Detail Level of Output: Med
...
 --------------------- Docker Begin ------------------------
 Container Started: 0 events
 Container Stopped: 0 events
 Image Pulled: 0 events
 ---------------------- Docker End -------------------------
```

#### 検証項目

- **アクション**: `sudo /usr/sbin/logwatch --detail Med --range today` を実行する
- **期待結果**: ログレポートが生成され、エラーなく表示される
- **アクション**: `ls -l /etc/logwatch/scripts/services/docker` を実行し、スクリプトが存在し実行権限が付与されていることを確認する
- **期待結果**: `-rwxr-xr-x` など実行可能な権限でファイルが表示される
- **失敗時**: `/var/log/logwatch/` ディレクトリの権限確認、logwatch再インストール、スクリプト再配置（`sudo tee` と `chmod +x` を再実行）

---

### ステップ8: logwatch日次実行のcron設定

logwatchを毎日午前3時に実行するよう設定します。

#### 実行コマンド

```bash
# cron設定ファイルの作成
sudo tee /etc/cron.daily/0logwatch > /dev/null <<'EOF'
#!/bin/bash
/usr/sbin/logwatch --output stdout --format text --range yesterday --detail med
EOF

# 実行権限付与
sudo chmod +x /etc/cron.daily/0logwatch

# cronサービスの状態確認
sudo systemctl status crond

# 設定確認
ls -la /etc/cron.daily/0logwatch
```

#### 期待される出力

```
-rwxr-xr-x 1 root root ... /etc/cron.daily/0logwatch
```

#### 検証項目

- **アクション**: `sudo /etc/cron.daily/0logwatch | head -20` を実行し、レポートが生成されるか確認する
- **期待結果**: ログレポートが表示される
- **失敗時**: スクリプトの実行権限確認 `chmod +x`、crondサービス起動確認

---

### ステップ9: Discord Webhookの作成（アラート通知用）

重大エラー・セキュリティインシデントの通知用にDiscord Webhookを作成します。

#### Discord側での操作

1. Discordサーバーを開く（または新規作成）
2. チャンネル設定 → 連携サービス → Webhook
3. 「新しいWebhook」をクリック
4. Webhook名を設定（例: Dell-Alerts）
5. 「Webhook URLをコピー」をクリック

#### 実行コマンド（サーバー側）

```bash
# Webhook URL を環境変数として設定（一時的）
DISCORD_WEBHOOK_URL="https://discord.com/api/webhooks/xxxxx/yyyyy"

# テスト通知の送信
curl -H "Content-Type: application/json" \
     -d "{\"content\": \"[TEST] Docker基盤構築完了 - Dell WorkStation\"}" \
     "$DISCORD_WEBHOOK_URL"
```

#### 期待される出力

Discordチャンネルに「[TEST] Docker基盤構築完了 - Dell WorkStation」というメッセージが表示される

#### 検証項目

- **アクション**: Discordチャンネルを確認する
- **期待結果**: テストメッセージが表示される
- **失敗時**: Webhook URLの確認、curlコマンド構文確認、ネットワーク接続確認

---

### ステップ10: アラート通知スクリプトの作成

重大エラー検知時にDiscord通知を送信するスクリプトを作成します。

#### 実行コマンド

**オプション1: GPG暗号化保存（推奨）**

```bash
# Webhook URLの暗号化保存
sudo mkdir -p /root/.config
echo "DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/xxxxx/yyyyy" | \
  gpg --symmetric --cipher-algo AES256 -o /root/.config/discord-webhook.gpg
sudo chmod 600 /root/.config/discord-webhook.gpg

# 復号化テスト
gpg --quiet --decrypt /root/.config/discord-webhook.gpg 2>/dev/null
```

**オプション2: 平文保存（簡易版、セキュリティ低い）**

```bash
# Webhook URLの平文保存
sudo mkdir -p /root/.config
echo "DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/xxxxx/yyyyy" | \
  sudo tee /root/.config/discord-webhook > /dev/null
sudo chmod 600 /root/.config/discord-webhook
```

**アラート通知スクリプトの作成（GPG復号化対応版）**

```bash
# アラート通知スクリプトの作成（GPG復号化対応版）
sudo tee /usr/local/bin/send-alert.sh > /dev/null <<'EOF'
#!/bin/bash

# アラート通知スクリプト（GPG暗号化対応）
# 使用例: send-alert.sh "エラーメッセージ"

# GPG暗号化ファイルが存在する場合は復号化
if [ -f /root/.config/discord-webhook.gpg ]; then
    WEBHOOK_URL=$(gpg --quiet --decrypt /root/.config/discord-webhook.gpg 2>/dev/null | grep -oP 'DISCORD_WEBHOOK_URL=\K.*')
# 平文ファイルが存在する場合はそのまま読み込み
elif [ -f /root/.config/discord-webhook ]; then
    source /root/.config/discord-webhook
    WEBHOOK_URL="$DISCORD_WEBHOOK_URL"
else
    echo "ERROR: Discord webhook not configured"
    exit 1
fi

# 共通設定項目(引数で受け取ったメッセージ)
MESSAGE="$1"
HOSTNAME=$(hostname)
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# 共通設定項目(Discordに通知送信)
curl -H "Content-Type: application/json" \
     -d "{\"content\": \"[ALERT] $HOSTNAME - $TIMESTAMP\n$MESSAGE\"}" \
     "$WEBHOOK_URL" 2>/dev/null

exit 0
EOF

# 実行権限付与
sudo chmod +x /usr/local/bin/send-alert.sh

# テスト実行
sudo /usr/local/bin/send-alert.sh "セキュリティ監視システム起動完了"
```

#### 期待される出力

Discordに「[ALERT] dell-workstation - 2024-xx-xx xx:xx:xx セキュリティ監視システム起動完了」が表示される

#### 検証項目

- **アクション**: Discordチャンネルを確認する
- **期待結果**: アラートメッセージが表示される
- **失敗時**: Webhook URL確認、スクリプトの実行権限確認

---

### ステップ11: fail2banアクション設定の作成

fail2banでIPブロック時にDiscord通知を送信するアクション設定を作成します（ステップ4で既に統合済み）。

#### 実行コマンド

```bash
# fail2banアクション設定の作成
sudo tee /etc/fail2ban/action.d/discord-notify.conf > /dev/null <<'EOF'
[Definition]
actionstart =
actionstop =
actioncheck =
actionban = /usr/local/bin/send-alert.sh "fail2ban: IP <ip> banned for <failures> failures on <name>"
actionunban =

[Init]
EOF

# fail2banサービスの再起動
sudo systemctl restart fail2ban

# 設定確認
sudo fail2ban-client status
```

#### 期待される出力

```
Status
|- Number of jail:      1
`- Jail list:   sshd
```

#### 検証項目

- **アクション**: `sudo fail2ban-client status sshd` を実行する
- **期待結果**: エラーなく実行され、sshdジェイルが有効、アクションに discord-notify が含まれる
- **失敗時**: `/var/log/fail2ban.log` でエラー確認、設定ファイル構文確認

**注意**: ステップ4でjail.d/custom.confに既にdiscord-notifyアクションを設定済みです。このステップではアクション定義のみを作成します。

---

### ステップ12: システム監視スクリプトの作成（リソース監視 + アラート頻度制御）

CPU・メモリ・ディスク使用率を監視し、閾値超過時にアラート送信するスクリプトを作成します。

#### 実行コマンド

```bash
# 監視スクリプトの作成（アラート頻度制御機能付き）
sudo tee /usr/local/bin/system-monitor.sh > /dev/null <<'EOF'
#!/bin/bash

# システムリソース監視スクリプト（アラート抑制機能付き）
# 実行頻度: 10分ごと

# 閾値設定
CPU_THRESHOLD=80
MEM_THRESHOLD=70
DISK_THRESHOLD=80

# アラート抑制設定
ALERT_STATE_FILE="/var/run/system-monitor-alerts.state"
THROTTLE_SECONDS=3600  # 同一アラートは1時間に1回まで

# アラート抑制ロジック付き送信関数
send_throttled_alert() {
    local alert_key="$1"
    local message="$2"

    # 状態ファイルの作成（初回実行時）
    [ ! -f "$ALERT_STATE_FILE" ] && sudo touch "$ALERT_STATE_FILE"

    # 前回送信時刻確認
    if [ -f "$ALERT_STATE_FILE" ]; then
        last_alert=$(grep "^$alert_key:" "$ALERT_STATE_FILE" | cut -d: -f2)
        current_time=$(date +%s)

        # 前回送信から規定時間経過していない場合は抑制
        if [ -n "$last_alert" ] && [ $((current_time - last_alert)) -lt $THROTTLE_SECONDS ]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Alert suppressed: $alert_key (sent $(( (current_time - last_alert) / 60 )) min ago)"
            return 0
        fi
    fi

    # アラート送信
    /usr/local/bin/send-alert.sh "$message"

    # 送信時刻を記録（既存エントリを更新または新規追加）
    if grep -q "^$alert_key:" "$ALERT_STATE_FILE" 2>/dev/null; then
        sudo sed -i "s/^$alert_key:.*/$alert_key:$(date +%s)/" "$ALERT_STATE_FILE"
    else
        echo "$alert_key:$(date +%s)" | sudo tee -a "$ALERT_STATE_FILE" > /dev/null
    fi
}

# CPU使用率確認
CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d'.' -f1)
if [ "$CPU_USAGE" -gt "$CPU_THRESHOLD" ]; then
    send_throttled_alert "cpu_high" "CPU使用率が高い: ${CPU_USAGE}% (閾値: ${CPU_THRESHOLD}%)"
fi

# メモリ使用率確認
MEM_USAGE=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100)}')
if [ "$MEM_USAGE" -gt "$MEM_THRESHOLD" ]; then
    send_throttled_alert "memory_high" "メモリ使用率が高い: ${MEM_USAGE}% (閾値: ${MEM_THRESHOLD}%)"
fi

# ディスク使用率確認
DISK_USAGE=$(df -h /data | tail -1 | awk '{print $5}' | cut -d'%' -f1)
if [ "$DISK_USAGE" -gt "$DISK_THRESHOLD" ]; then
    send_throttled_alert "disk_high" "ディスク使用率が高い: ${DISK_USAGE}% (閾値: ${DISK_THRESHOLD}%)"
fi

exit 0
EOF

# 実行権限付与
sudo chmod +x /usr/local/bin/system-monitor.sh

# cron設定（10分ごと実行）
echo "*/10 * * * * root /usr/local/bin/system-monitor.sh" | sudo tee /etc/cron.d/system-monitor > /dev/null

# テスト実行
sudo /usr/local/bin/system-monitor.sh
```

#### 期待される出力

（閾値を超えていない場合）何も表示されない、または（閾値超過時）Discordにアラート送信

#### 検証項目

- **アクション**: `sudo /usr/local/bin/system-monitor.sh` を実行し、エラーなく完了するか確認する
- **期待結果**: スクリプトがエラーなく実行される
- **失敗時**: スクリプト内のコマンド確認、top/free/dfが正常動作するか確認

---

## 包括的動作確認手順

### 1. SSH公開鍵認証確認

```bash
# ローカルマシンから接続テスト
ssh username@dell-workstation

# パスワード認証が無効か確認（別端末で試行）
ssh -o PreferredAuthentications=password username@dell-workstation
# → Permission denied (publickey) が表示されればOK
```

**期待される結果**:
- 公開鍵認証でログイン成功
- パスワード認証は拒否される

---

### 2. fail2ban動作確認

```bash
# fail2ban状態確認
sudo fail2ban-client status sshd

# ログ確認
sudo tail -30 /var/log/fail2ban.log

# ブロックテスト（意図的な失敗ログイン、別マシンから実施）
# 5回連続で失敗 → IPブロック → Discord通知
```

**期待される結果**:
- fail2banが動作中
- 5回失敗後にIPブロックされる
- Discordにアラートが届く

---

### 3. SELinux状態確認

```bash
# SELinuxモード確認
getenforce

# AVC拒否ログ確認
sudo ausearch -m avc -ts recent

# SELinux違反確認
sudo sealert -a /var/log/audit/audit.log
```

**期待される結果**:
- Enforcing モード
- 重大なAVC拒否ログがない

---

### 4. 自動アップデート確認

```bash
# dnf-automaticタイマー確認
sudo systemctl status dnf-automatic.timer

# 次回実行時刻確認
sudo systemctl list-timers dnf-automatic.timer

# ログ確認
sudo journalctl -u dnf-automatic --since yesterday
```

**期待される結果**:
- タイマーが有効
- 定期的に実行されている

---

### 5. logwatch確認

```bash
# 手動実行テスト
sudo logwatch --detail Med --range today --output stdout | less

# cron設定確認
ls -la /etc/cron.daily/0logwatch

# 実行ログ確認（翌日以降）
sudo grep logwatch /var/log/cron
```

**期待される結果**:
- レポートが正常生成される
- 日次で自動実行される

---

### 6. Discord通知確認

```bash
# テスト通知送信
sudo /usr/local/bin/send-alert.sh "監視システム動作確認テスト"

# システム監視スクリプト手動実行
sudo /usr/local/bin/system-monitor.sh
```

**期待される結果**:
- Discordにメッセージが届く
- システム監視が正常動作

---

## 最終確認チェックリスト

以下の全項目が ✅ になることを確認してください：

- [ ] SSH公開鍵認証でログインできる
- [ ] SSHパスワード認証が無効化されている
- [ ] fail2banがインストールされ、起動している（`systemctl status fail2ban`）
- [ ] SELinuxがEnforcingモードで動作している（`getenforce`）
- [ ] dnf-automaticタイマーが有効（`systemctl is-enabled dnf-automatic.timer`）
- [ ] logwatchがインストールされている（`which logwatch`）
- [ ] logwatch日次実行cronが設定されている（`ls /etc/cron.daily/0logwatch`）
- [ ] Discord Webhookが設定されている（`ls /root/.config/discord-webhook`）
- [ ] アラート通知スクリプトが動作する（`sudo /usr/local/bin/send-alert.sh "test"`）
- [ ] fail2ban→Discord通知が統合されている
- [ ] システム監視スクリプトが動作する（`sudo /usr/local/bin/system-monitor.sh`）
- [ ] システム監視cronが設定されている（`cat /etc/cron.d/system-monitor`）

## 次のステップ

**✅ 上記の全確認項目が成功した場合のみ**、次の手順に進んでください。

- **Phase 3.4**: 統合テスト（`procedures/3.4-infrastructure-validation.md`）

問題が発見された場合は、該当するトラブルシューティングセクションを参照して解決してから次のフェーズに進行してください。

## トラブルシューティング

### SSH公開鍵認証でログインできない

**症状**: `ssh username@dell-workstation` がパスワードを要求する

**確認**:
```bash
# サーバー側
ls -la ~/.ssh/authorized_keys
cat ~/.ssh/authorized_keys
```

**原因と対策**:
1. **authorized_keys権限エラー**: `chmod 600 ~/.ssh/authorized_keys` と `chmod 700 ~/.ssh`
2. **公開鍵未登録**: ローカルマシンから `ssh-copy-id` を再実行
3. **SELinuxコンテキスト**: `restorecon -R ~/.ssh`

---

### fail2ban起動失敗

**症状**: `sudo systemctl start fail2ban` がエラー

**確認**:
```bash
sudo journalctl -u fail2ban -xe
sudo fail2ban-client -vvv
```

**原因と対策**:
1. **設定ファイル構文エラー**: `/etc/fail2ban/jail.d/custom.conf` 確認
2. **ログファイル不在**: `/var/log/secure` 存在確認
3. **ポート指定ミス**: jail設定のport番号確認

---

### SELinuxがEnforcingにならない

**症状**: `getenforce` が Permissive または Disabled

**確認**:
```bash
sudo cat /etc/selinux/config
```

**原因と対策**:
1. **設定ファイル修正**: `SELINUX=enforcing` に変更
2. **OS再起動**: `sudo reboot` 実行後に再確認
3. **カーネルパラメータ**: `grubby --update-kernel ALL --remove-args selinux` 確認

---

### dnf-automatic実行されない

**症状**: 自動アップデートが実行されない

**確認**:
```bash
sudo systemctl status dnf-automatic.timer
sudo journalctl -u dnf-automatic --since "1 week ago"
```

**原因と対策**:
1. **タイマー無効**: `sudo systemctl enable --now dnf-automatic.timer`
2. **設定エラー**: `/etc/dnf/automatic.conf` 確認
3. **ネットワーク問題**: `sudo dnf check-update` で手動確認

---

### Discord通知が届かない

**症状**: `send-alert.sh` 実行してもDiscordに通知されない

**確認**:
```bash
sudo cat /root/.config/discord-webhook
curl -v https://discord.com/api/webhooks/xxxxx/yyyyy
```

**原因と対策**:
1. **Webhook URL間違い**: Discord側で再生成、設定ファイル更新
2. **ネットワーク問題**: `curl https://discord.com` で接続確認
3. **権限エラー**: `/root/.config/discord-webhook` の権限を600に設定

---

## 修正履歴

### Version 1.1 (2025-01-28)
**修正内容**:

1. **SSH設定変更時の安全確認プロセス強化** (課題#1対応 - 🔴 CRITICAL)
   - 理由: 公開鍵認証が動作しない状態でパスワード認証を無効化するとログイン不可能になるリスク
   - 追加機能:
     - Phase 1-4の段階的確認フロー
     - 既存セッション維持したまま設定変更
     - 3回以上の公開鍵認証動作確認を必須化
     - 詳細なロールバック手順（セッション維持版、コンソールアクセス版）
     - タイムスタンプ付きバックアップ
   - 影響: SSH接続不能リスクの完全排除

2. **fail2ban設定ファイルの重複セクション修正** (課題#2対応 - 🔴 CRITICAL)
   - 理由: ステップ4とステップ11で `/etc/fail2ban/jail.d/custom.conf` の `[sshd]` セクションを2回定義していた
   - 変更:
     - ステップ4でDiscord通知統合を含む完全な設定を1回で実施
     - ステップ11はアクション定義（discord-notify.conf）のみ作成に変更
   - 影響: fail2ban設定エラーの防止

3. **fail2ban bantime設定の延長** (課題#8対応 - 🟡 IMPORTANT)
   - 理由: 10分間のBanは短すぎてブルートフォース攻撃に対して脆弱
   - 変更: `bantime = 600` → `bantime = 3600` (10分 → 1時間)
   - 影響: セキュリティ強化、攻撃者の再試行を1時間遮断

4. **Discord Webhook URLの暗号化保存** (課題#6対応 - 🟡 IMPORTANT)
   - 理由: 機密情報（Webhook URL）が平文で保存されていた
   - 追加機能:
     - オプション1（推奨）: GPG対称鍵暗号化（AES256）による保存
     - オプション2（簡易版）: 平文保存（権限600で保護）
     - send-alert.sh スクリプトのGPG復号化対応
   - コマンド例:
     ```bash
     echo "WEBHOOK_URL=..." | gpg --symmetric --cipher-algo AES256 -o /root/.config/discord-webhook.gpg
     ```
   - 影響: Webhook URLの機密性向上

5. **システム監視アラートの頻度制御** (課題#9対応 - 🟡 IMPORTANT)
   - 理由: 10分ごとに閾値チェックで連続アラートが発生する可能性があった
   - 追加機能:
     - アラート抑制ロジック（`send_throttled_alert`関数）
     - 同一アラートは1時間に1回まで（`THROTTLE_SECONDS=3600`）
     - 状態ファイル `/var/run/system-monitor-alerts.state` による送信時刻管理
     - アラートキー別管理（cpu_high, memory_high, disk_high）
   - 影響: アラート疲れの防止、重要なアラートの見逃し防止

**各課題の変更箇所**:
- 課題#1: ステップ3全体を安全確認フロー版に置換
- 課題#2: ステップ4にDiscord通知統合、ステップ11を説明のみに変更
- 課題#8: ステップ4の `bantime = 600` → `bantime = 3600`
- 課題#6: ステップ10にGPG暗号化オプション追加、send-alert.sh を復号化対応版に変更
- 課題#9: ステップ12のsystem-monitor.shにアラート抑制ロジック追加

**影響度評価**:
- 🔴 CRITICAL: SSH設定変更プロセス（課題#1）、fail2ban設定重複（課題#2）
- 🟡 IMPORTANT: bantime延長（課題#8）、Webhook暗号化（課題#6）、アラート頻度制御（課題#9）

---

**END OF DOCUMENT**
